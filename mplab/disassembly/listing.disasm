Disassembly Listing for DMX-Dimmer
Generated From:
D:/projekte/11-MyHomeLight/DMX-Dimmer/dist/C18_18F14K22/debug/DMX-Dimmer.debug.elf
26.09.2014 06:35:14

---  D:/projekte/11-MyHomeLight/DMX-Dimmer/pwm.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include "pwm.h"
3:             #include "channels.h"
4:             
5:             /*
6:              * Version 1.0
7:              */
8:             
9:             #define MAXCHANNELS 4
10:            
11:            extern CHANNELINFO *pCIRead;
12:            
13:            
14:            void pwmStepA(void);
15:            void pwmStepB(void);
16:            
17:            
18:            void initPwm(void)  {
19:            
20:                unsigned  char i;
21:            
22:                INTCONbits.TMR0IF = 0;
093C  94F2     BCF INTCON, 2, ACCESS
23:            
24:                T0CON              = 0b10000001;
093E  0E81     MOVLW 0x81
0940  6ED5     MOVWF T0CON, ACCESS
25:            
26:                INTCON2bits.TMR0IP = 1;   // Timer 0 Interrupt Priority : LOW
0942  84F1     BSF INTCON2, 2, ACCESS
27:                INTCONbits.TMR0IE  = 1;   // Timer 0 Interupt Enable
0944  8AF2     BSF INTCON, 5, ACCESS
28:            
29:                INTCONbits.GIEH    = 1;  // High Prio Interupts enable
0946  8EF2     BSF INTCON, 7, ACCESS
30:                INTCONbits.GIEL    = 1;  // Low Prio Interupts enable
0948  8CF2     BSF INTCON, 6, ACCESS
31:            
32:                INTCONbits.PEIE    = 1;  // Peripherals Interupts Enable
094A  8CF2     BSF INTCON, 6, ACCESS
33:            }
094C  0012     RETURN 0
34:            
35:            
36:            /*
37:             * Variablen Global allokiert; schnellerer Zugriff möglich
38:             */
39:            
40:            unsigned char intCount = 0;
41:            unsigned int  tTmp;
42:            
43:            void pwmStep(void)  {
44:            
45:                tTmp = pCIRead -> timer[intCount]; 
063C  503B     MOVF intCount, W, ACCESS
063E  0D02     MULLW 0x2
0640  0E01     MOVLW 0x1
0642  26F3     ADDWF PROD, F, ACCESS
0644  0E00     MOVLW 0x0
0646  22F4     ADDWFC PRODH, F, ACCESS
0648  50F3     MOVF PROD, W, ACCESS
064A  242F     ADDWF pCIRead, W, ACCESS
064C  6ED9     MOVWF FSR2, ACCESS
064E  50F4     MOVF PRODH, W, ACCESS
0650  2030     ADDWFC 0x30, W, ACCESS
0652  6EDA     MOVWF FSR2H, ACCESS
0654  CFDE     MOVFF POSTINC2, tTmp
0656  F033     NOP
0658  CFDD     MOVFF POSTDEC2, 0x34
065A  F034     NOP
46:            
47:                TMR0H = ((tTmp >> 8) & 0xFF);
065C  C034     MOVFF 0x34, 0x12
065E  F012     NOP
0660  C012     MOVFF 0x12, 0x13
0662  F013     NOP
0664  6A14     CLRF 0x14, ACCESS
0666  5013     MOVF 0x13, W, ACCESS
0668  6ED7     MOVWF TMR0H, ACCESS
48:                TMR0L = (tTmp & 0xFF);
066A  C033     MOVFF tTmp, TMR0
066C  FFD6     NOP
49:            
50:                if (intCount == 0)  {
066E  663B     TSTFSZ intCount, ACCESS
0670  D011     BRA 0x694
51:                    swapBuffers();
0672  EC78     CALL 0x8F0, 0
0674  F004     NOP
52:                    PORTC = pCIRead -> bitmask[intCount];
0676  503B     MOVF intCount, W, ACCESS
0678  0D01     MULLW 0x1
067A  0E0B     MOVLW 0xB
067C  26F3     ADDWF PROD, F, ACCESS
067E  0E00     MOVLW 0x0
0680  22F4     ADDWFC PRODH, F, ACCESS
0682  50F3     MOVF PROD, W, ACCESS
0684  242F     ADDWF pCIRead, W, ACCESS
0686  6ED9     MOVWF FSR2, ACCESS
0688  50F4     MOVF PRODH, W, ACCESS
068A  2030     ADDWFC 0x30, W, ACCESS
068C  6EDA     MOVWF FSR2H, ACCESS
068E  50DF     MOVF INDF2, W, ACCESS
0690  6E82     MOVWF PORTC, ACCESS
53:                }
0692  D00F     BRA 0x6B2
54:                else  {
55:                    PORTC &= ~(pCIRead -> bitmask[intCount]);
0694  503B     MOVF intCount, W, ACCESS
0696  0D01     MULLW 0x1
0698  0E0B     MOVLW 0xB
069A  26F3     ADDWF PROD, F, ACCESS
069C  0E00     MOVLW 0x0
069E  22F4     ADDWFC PRODH, F, ACCESS
06A0  50F3     MOVF PROD, W, ACCESS
06A2  242F     ADDWF pCIRead, W, ACCESS
06A4  6ED9     MOVWF FSR2, ACCESS
06A6  50F4     MOVF PRODH, W, ACCESS
06A8  2030     ADDWFC 0x30, W, ACCESS
06AA  6EDA     MOVWF FSR2H, ACCESS
06AC  50DF     MOVF INDF2, W, ACCESS
06AE  0AFF     XORLW 0xFF
06B0  1682     ANDWF PORTC, F, ACCESS
56:                }
57:            
58:                intCount = intCount >= pCIRead -> numInts ? 0 : intCount + 1;
06B2  C02F     MOVFF pCIRead, FSR2
06B4  FFD9     NOP
06B6  C030     MOVFF 0x30, FSR2H
06B8  FFDA     NOP
06BA  50DF     MOVF INDF2, W, ACCESS
06BC  5C3B     SUBWF intCount, W, ACCESS
06BE  B0D8     BTFSC STATUS, 0, ACCESS
06C0  D007     BRA 0x6D0
06C2  0E01     MOVLW 0x1
06C4  243B     ADDWF intCount, W, ACCESS
06C6  6E15     MOVWF 0x15, ACCESS
06C8  6A16     CLRF 0x16, ACCESS
06CA  0E00     MOVLW 0x0
06CC  2216     ADDWFC 0x16, F, ACCESS
06CE  D004     BRA 0x6D8
06D0  0E00     MOVLW 0x0
06D2  6E16     MOVWF 0x16, ACCESS
06D4  0E00     MOVLW 0x0
06D6  6E15     MOVWF 0x15, ACCESS
06D8  C015     MOVFF 0x15, intCount
06DA  F03B     NOP
59:            
60:            }
06DC  0012     RETURN 0
61:            
62:            /*
63:             ** Pointerarithmetik vermeiden; schneller werden
64:             ** Es zeigt sich, dass dennoch nix gespart wird.
65:            
66:             */
67:            
68:            extern CHANNELINFO ci1;
69:            extern CHANNELINFO ci2;
70:            
71:            void pwmStepA(void)  {
72:            
73:                tTmp = ci1.timer[intCount];
74:            
75:                TMR0H = ((tTmp >> 8) & 0xFF);
76:                TMR0L = (tTmp & 0xFF);
77:            
78:                if (intCount == 0)  {
79:                    swapBuffers();
80:                    PORTC = ci1.bitmask[intCount];
81:                }
82:                else  {
83:                    PORTC &= ~(ci1.bitmask[intCount]);
84:                }
85:            
86:                intCount = intCount >= ci1.numInts ? 0 : intCount + 1;
87:            
88:            }
89:            
90:            
91:            
---  D:/projekte/11-MyHomeLight/DMX-Dimmer/main.c  ------------------------------------------------------
1:             #include <xc.h>        /* XC8 General Include File */
2:             
3:             #include <stdint.h>        /* For uint8_t definition */
4:             #include <stdbool.h>       /* For true/false definition */
5:             
6:             #include "hardware.h"
7:             
8:             #include "pwm.h"
9:             #include "dmx.h"
10:            #include "channels.h"
11:            
12:            
13:            volatile unsigned char lastInChainReceived = 0;
14:            
15:            unsigned char counterForSimulator = 0;
16:            
17:            
18:            /*
19:             *
20:             */
21:            
22:            
23:            
24:            
25:            
26:            void main(void)
27:            {
28:            
29:             
30:            
31:               // int recv;
32:            
33:                initHardware();
08C6  EC2A     CALL 0x854, 0
08C8  F004     NOP
34:                initPwm();
08CA  EC9E     CALL 0x93C, 0
08CC  F004     NOP
35:                initChannels();
08CE  ECFC     CALL 0x7F8, 0
08D0  F003     NOP
36:                initDMX();
08D2  EC8D     CALL 0x91A, 0
08D4  F004     NOP
37:            
38:            
39:                RCONbits.IPEN = 1;
08D6  8ED0     BSF RCON, 7, ACCESS
40:            
41:            
42:                INTCONbits.GIEH = 1;
08D8  8EF2     BSF INTCON, 7, ACCESS
43:                INTCONbits.GIEL = 1;
08DA  8CF2     BSF INTCON, 6, ACCESS
44:            
45:            
46:                for (;;)  {
47:            
48:            /* Das funktionierte zwar so nicht, es hat sich aber gezeigt, dass das flackern weg ist. --> Interrupt schneller machen
49:                  if (PIR1bits.RCIF == 1)  {
50:                      handleDMX();
51:                      PIR1bits.RCIF = 0;
52:                  }
53:            */
54:            
55:            
56:                    if (lastInChainReceived /*|| counterForSimulator++ == 100 */)  {
08DC  503C     MOVF lastInChainReceived, W, ACCESS
08DE  B4D8     BTFSC STATUS, 2, ACCESS
08E0  D7FD     BRA 0x8DC
57:                        doRank();
08E2  ECC8     CALL 0x590, 0
08E4  F002     NOP
58:                        calculateTimerDiffsAndMask();
08E6  EC53     CALL 0xA6, 0
08E8  F000     NOP
59:                        lastInChainReceived = 0;
08EA  0E00     MOVLW 0x0
60:                    }
61:                }
62:            
63:            
64:            }
---  D:/projekte/11-MyHomeLight/DMX-Dimmer/interrupts.c  ------------------------------------------------
1:             #include <xc.h>         /* XC8 General Include File */
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             
5:             #include "dmx.h"
6:             #include "pwm.h"
7:             
8:             
9:             
10:            /* 
11:            ** High-priority service
12:            */
13:            
14:            void interrupt high_isr(void)  {
077E  CFEA     MOVFF FSR0H, 0x1A
15:            
16:            
17:            
18:               if ( INTCONbits.T0IF == 1)  {   // timer lasse ich einfach mal so mitlaufen, verwendung kommt noch
07AA  A4F2     BTFSS INTCON, 2, ACCESS
19:                   INTCONbits.T0IF = 0;
07AE  94F2     BCF INTCON, 2, ACCESS
20:                    pwmStep();
07B0  EC1E     CALL 0x63C, 0
21:            
22:               //     pwmStepA();
23:            
24:               }
25:            /**/
26:               if (PIR1bits.RCIF == 1)  {
07B4  AA9E     BTFSS PIR1, 5, ACCESS
27:            
28:                    handleDMX();
07B8  EC6F     CALL 0x6DE, 0
29:                    PIR1bits.RCIF = 0;
07BC  9A9E     BCF PIR1, 5, ACCESS
30:                }
31:            /**/
32:            
33:               return;
34:            
35:            }
07BE  C024     MOVFF 0x24, TABLAT
36:            
37:            
38:            
39:            /*
40:            ** Low prio Interrupt
41:            */
42:            
43:            void low_priority interrupt low_isr(void)  {
0018  CFD8     MOVFF STATUS, __pcstackCOMRAM
44:            
45:            /**/
46:              //  if ( INTCONbits.T0IF == 1)  {   // timer lasse ich einfach mal so mitlaufen, verwendung kommt noch
47:            
48:                 //   INTCONbits.T0IF = 0;
49:                 //   pwmStep();
50:            
51:            
52:                  //    handleDMX();
53:                  //  PIR1bits.RCIF = 0;
54:            
55:            
56:               //     TMR0H = 0xFF;
57:              //      TMR0L = 0xF0;
58:                //    handlePwm();
59:            
60:              //  }
61:            
62:            
63:            }
0008  CFFA     MOVFF PCLATH, 0x17
005C  C011     MOVFF 0x11, TABLAT
---  D:/projekte/11-MyHomeLight/DMX-Dimmer/hardware.c  --------------------------------------------------
1:             #include <xc.h>
2:             #include "hardware.h"
3:             
4:             
5:             
6:             void initHardware(void)  {
7:             
8:                                    // 8MHz internal OscillatorBlock
9:             
10:              OSCCONbits.IDLEN = 0;
0854  9ED3     BCF OSCCON, 7, ACCESS
11:            
12:              OSCCONbits.IRCF2 = 1;
0856  8CD3     BSF OSCCON, 6, ACCESS
13:              OSCCONbits.IRCF1 = 1;
0858  8AD3     BSF OSCCON, 5, ACCESS
14:              OSCCONbits.IRCF0 = 0;
085A  98D3     BCF OSCCON, 4, ACCESS
15:            
16:              OSCCONbits.SCS1  = 1;
085C  82D3     BSF OSCCON, 1, ACCESS
17:              OSCCONbits.SCS0  = 0;
085E  90D3     BCF OSCCON, 0, ACCESS
18:            
19:              /*
20:              ** I/O
21:              */
22:            
23:              CM1CON0  = 0;
0860  0E00     MOVLW 0x0
0862  6E6D     MOVWF CM1CON0, ACCESS
24:              CM2CON0  = 0;
0864  0E00     MOVLW 0x0
0866  6E6B     MOVWF CM2CON0, ACCESS
25:            //  SSP1CON = 0;
26:            
27:              ANSEL   = 0x00;
0868  0E00     MOVLW 0x0
086A  6E7E     MOVWF ANSEL, ACCESS
28:              ANSELH  = 0x00;
086C  0E00     MOVLW 0x0
086E  6E7F     MOVWF ANSELH, ACCESS
29:            
30:              LATA    = 0x00;
0870  0E00     MOVLW 0x0
0872  6E89     MOVWF LATA, ACCESS
31:              PORTA   = 0x00;
0874  0E00     MOVLW 0x0
0876  6E80     MOVWF PORTA, ACCESS
32:              TRISA   = TRISAMASK;              // 8 Mal Ausgang
0878  0E07     MOVLW 0x7
087A  6E92     MOVWF TRISA, ACCESS
33:            
34:            
35:            
36:             // CCP1CON = 0;                       // Comparators OFF
37:             // ADCON1  = 0x7F;
38:             // hat das bei diesem chip ne funktion???
39:            
40:              
41:              PORTB   = 0x00;
087C  0E00     MOVLW 0x0
087E  6E81     MOVWF PORTB, ACCESS
42:              LATB    = 0x00;
0880  0E00     MOVLW 0x0
0882  6E8A     MOVWF LATB, ACCESS
43:            //  ANSELB  = 0x00;
44:              TRISB   = TRISBMASK;
0884  0E27     MOVLW 0x27
0886  6E93     MOVWF TRISB, ACCESS
45:            
46:              LATC    = 0x00;
0888  0E00     MOVLW 0x0
088A  6E8B     MOVWF LATC, ACCESS
47:              PORTC   = 0x00;
088C  0E00     MOVLW 0x0
088E  6E82     MOVWF PORTC, ACCESS
48:            //  ANSELC  = 0x00;
49:              TRISC   = TRISCMASK;              
0890  0E30     MOVLW 0x30
0892  6E94     MOVWF TRISC, ACCESS
50:            
51:            
52:            }
0894  0012     RETURN 0
---  D:/projekte/11-MyHomeLight/DMX-Dimmer/dmx.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include "dmx.h"
3:             #include "pwm.h"
4:             #include "channels.h"
5:             
6:             
7:             /*
8:             ** Baudrate
9:             ** Datasheet Page 280
10:            */
11:            
12:            #define MEGAHERTZ 1000000
13:            #define FOSC (8 * MEGAHERTZ)
14:            
15:            
16:            #define BASEADDRESS 4
17:            
18:            
19:            unsigned char dmxState; 
20:            unsigned int  currentAdress;
21:            
22:            
23:            
24:            //unsigned char lampenwerte[32];
25:            
26:            extern unsigned char lastInChainReceived;
27:            
28:            unsigned char channelLevel[MAXCHANNELS];
29:            
30:            
31:            void initDMX(void)  {
32:            
33:            
34:            
35:                BAUDCONbits.BRG16 = 1;     // Baudratengenerator 8-Bit
091A  86B8     BSF BAUDCON, 3, ACCESS
36:                BAUDCONbits.CKTXP = 1;     // polaritaet verdrehen
091C  88B8     BSF BAUDCON, 4, ACCESS
37:            //    TXSTA1bits.BRGH    = 0;     //
38:                SPBRG1             = 1;     // Baudrate einstellen
091E  0E01     MOVLW 0x1
0920  6EAF     MOVWF SPBRG, ACCESS
39:                SPBRGH            = 0;     //
0922  0E00     MOVLW 0x0
0924  6EB0     MOVWF SPBRGH, ACCESS
40:            
41:                RCSTA1bits.CREN = 1;
0926  88AB     BSF RCSTA, 4, ACCESS
42:            
43:                RCSTA1bits.SPEN = 1;
0928  8EAB     BSF RCSTA, 7, ACCESS
44:            
45:                PIE1bits.RCIE = 1;
092A  8A9D     BSF PIE1, 5, ACCESS
46:                IPR1bits.RCIP = 1;
092C  8A9F     BSF IPR1, 5, ACCESS
47:            
48:            
49:                currentAdress = 0;
092E  0E00     MOVLW 0x0
0930  6E2E     MOVWF 0x2E, ACCESS
0932  0E00     MOVLW 0x0
0934  6E2D     MOVWF currentAdress, ACCESS
50:              //  baseAdress    = 0;
51:            
52:                dmxState      = DMX_NOTSYNCED;
0936  0E00     MOVLW 0x0
0938  6E38     MOVWF dmxState, ACCESS
53:            
54:            }
093A  0012     RETURN 0
55:            
56:            unsigned char errflag;
57:            unsigned char received;
58:            
59:            unsigned char dummy;
60:            
61:            void handleDMX()  {
62:            
63:               /*
64:               ** error-flag holen ( muss vor dem lesen der eigentlichen date gemacht werden )
65:               */
66:               errflag = FERR;
06DE  0E00     MOVLW 0x0
06E0  B4AB     BTFSC RCSTA, 2, ACCESS
06E2  0E01     MOVLW 0x1
06E4  6E3A     MOVWF errflag, ACCESS
67:            
68:              /*
69:               ** Das Empfangene Byte holen
70:               */
71:               received = RCREG;
06E6  CFAE     MOVFF RCREG, received
06E8  F03F     NOP
72:            
73:               if ((errflag == 1) && ( dmxState == DMX_NOTSYNCED)  )  {
06EA  043A     DECF errflag, W, ACCESS
06EC  A4D8     BTFSS STATUS, 2, ACCESS
06EE  D009     BRA 0x702
06F0  6638     TSTFSZ dmxState, ACCESS
06F2  D007     BRA 0x702
74:                   currentAdress = 0;
06F4  0E00     MOVLW 0x0
06F6  6E2E     MOVWF 0x2E, ACCESS
06F8  0E00     MOVLW 0x0
06FA  6E2D     MOVWF currentAdress, ACCESS
75:                   dmxState = DMX_WAITSTART;
06FC  0E01     MOVLW 0x1
06FE  6E38     MOVWF dmxState, ACCESS
0700  0012     RETURN 0
76:                   return;
77:               }
78:            
79:               if ( (dmxState == DMX_WAITSTART) && (received == 0x00))  {
0702  0438     DECF dmxState, W, ACCESS
0704  A4D8     BTFSS STATUS, 2, ACCESS
0706  D005     BRA 0x712
0708  663F     TSTFSZ received, ACCESS
070A  D003     BRA 0x712
80:            
81:                  dmxState = DMX_PAYLOAD;
070C  0E02     MOVLW 0x2
070E  6E38     MOVWF dmxState, ACCESS
0710  0012     RETURN 0
82:                  return;
83:               }
84:            
85:               if ( dmxState == DMX_PAYLOAD)  {
0712  5038     MOVF dmxState, W, ACCESS
0714  0A02     XORLW 0x2
0716  A4D8     BTFSS STATUS, 2, ACCESS
0718  0012     RETURN 0
86:            
87:                  if (currentAdress >= BASEADDRESS &&  currentAdress < BASEADDRESS + 4)  {
071A  0E04     MOVLW 0x4
071C  5C2D     SUBWF currentAdress, W, ACCESS
071E  0E00     MOVLW 0x0
0720  582E     SUBWFB 0x2E, W, ACCESS
0722  A0D8     BTFSS STATUS, 0, ACCESS
0724  D01A     BRA 0x75A
0726  0E08     MOVLW 0x8
0728  5C2D     SUBWF currentAdress, W, ACCESS
072A  0E00     MOVLW 0x0
072C  582E     SUBWFB 0x2E, W, ACCESS
072E  B0D8     BTFSC STATUS, 0, ACCESS
0730  D014     BRA 0x75A
88:                    //  setChannelValue(currentAdress-BASEADDRESS, received);
89:            
90:                    //  if ( channelLevel[currentAdress-BASEADDRESS] == 0 && received != 0)  {
91:            
92:                    //      dummy = LATA;  // zum Setzen des Breakdowns
93:            
94:                    //  }
95:            
96:                      channelLevel[currentAdress-BASEADDRESS] = received;
0732  0EFC     MOVLW 0xFC
0734  6E12     MOVWF 0x12, ACCESS
0736  0EFF     MOVLW 0xFF
0738  6E13     MOVWF 0x13, ACCESS
073A  C02D     MOVFF currentAdress, 0x14
073C  F014     NOP
073E  C02E     MOVFF 0x2E, 0x15
0740  F015     NOP
0742  5012     MOVF 0x12, W, ACCESS
0744  2614     ADDWF 0x14, F, ACCESS
0746  5013     MOVF 0x13, W, ACCESS
0748  2215     ADDWFC 0x15, F, ACCESS
074A  0E25     MOVLW 0x25
074C  2414     ADDWF 0x14, W, ACCESS
074E  6ED9     MOVWF FSR2, ACCESS
0750  0E00     MOVLW 0x0
0752  2015     ADDWFC 0x15, W, ACCESS
0754  6EDA     MOVWF FSR2H, ACCESS
0756  C03F     MOVFF received, INDF2
0758  FFDF     NOP
97:            
98:                // An Interruptüberholern scheint das blitzen am anfang nicht zu liegen. 
99:                // sowohl die frequenzverringerung als auch die diskriminierung des niedrigen bereichs
100:               // bringt Nüscht
101:               //
102:               // Doc hein Issue in der Datenaufbereitung?
103:           
104:           
105:           
106:           //       if ( currentAdress < 4)  {
107:           //          setChannelValue(currentAdress, received);
108:                   
109:           
110:                 }
111:                // if (currentAdress == BASEADDRESS + 4)
112:           
113:                 if (currentAdress ==  BASEADDRESS + 4)
075A  502D     MOVF currentAdress, W, ACCESS
075C  0A08     XORLW 0x8
075E  102E     IORWF 0x2E, W, ACCESS
0760  A4D8     BTFSS STATUS, 2, ACCESS
0762  D002     BRA 0x768
114:                    lastInChainReceived = 1;
0764  0E01     MOVLW 0x1
0766  6E3C     MOVWF lastInChainReceived, ACCESS
115:           
116:                 currentAdress++;
0768  4A2D     INFSNZ currentAdress, F, ACCESS
076A  2A2E     INCF 0x2E, F, ACCESS
117:           
118:                 if ( currentAdress >= 128)
076C  0E80     MOVLW 0x80
076E  5C2D     SUBWF currentAdress, W, ACCESS
0770  0E00     MOVLW 0x0
0772  582E     SUBWFB 0x2E, W, ACCESS
0774  A0D8     BTFSS STATUS, 0, ACCESS
0776  0012     RETURN 0
119:                    dmxState = DMX_NOTSYNCED;
0778  0E00     MOVLW 0x0
120:           
121:              }
122:           
123:           
124:           
125:           }
126:           
---  D:/projekte/11-MyHomeLight/DMX-Dimmer/channels.c  --------------------------------------------------
1:             #include <xc.h>
2:             #include "channels.h"
3:             
4:             /*
5:              * Version 1.0 Septtember 2014
6:              * Dimmen funktioniert, allerdings mit Flicker
7:              */
8:             
9:             
10:            /*
11:            ** Die Kanalwerte
12:            */
13:            unsigned char channelLevel[MAXCHANNELS];
14:            
15:            static unsigned char channelRank[MAXCHANNELS];
16:            
17:            /*
18:            unsigned int  timer[2][MAXCHANNELS + 1];
19:            unsigned char bitmasks[2][MAXCHANNELS + 1];
20:            unsigned int  numInts[2]; 
21:            */
22:            
23:            unsigned char readIndex  = 0;
24:            unsigned char writeIndex = 1;
25:            
26:            CHANNELINFO ci1;
27:            CHANNELINFO ci2;
28:            
29:            CHANNELINFO *pCIRead;
30:            CHANNELINFO *pCIWrite;
31:            CHANNELINFO *pCITmp;
32:            
33:            /*
34:            ** Klar: Bringt das Ganze in einen definierten Anfangszustand
35:            */
36:            
37:            void initChannels()  {
38:                
39:                unsigned char i; 
40:                
41:                for (i = 0; i < MAXCHANNELS; i++)  {
07F8  0E00     MOVLW 0x0
07FA  0100     MOVLB 0x0
07FC  6F80     MOVWF __pcstackBANK0, BANKED
07FE  D00D     BRA 0x81A
0816  0100     MOVLB 0x0
0818  2B80     INCF __pcstackBANK0, F, BANKED
081A  0E03     MOVLW 0x3
081C  0100     MOVLB 0x0
081E  6580     CPFSGT __pcstackBANK0, BANKED
0820  D7EF     BRA 0x800
42:                    channelLevel[i] = 0; 
0800  0100     MOVLB 0x0
0802  5180     MOVF __pcstackBANK0, W, BANKED
0804  0D01     MULLW 0x1
0806  0E25     MOVLW 0x25
0808  24F3     ADDWF PROD, W, ACCESS
080A  6ED9     MOVWF FSR2, ACCESS
080C  0E00     MOVLW 0x0
080E  20F4     ADDWFC PRODH, W, ACCESS
0810  6EDA     MOVWF FSR2H, ACCESS
0812  0E00     MOVLW 0x0
0814  6EDF     MOVWF INDF2, ACCESS
43:                }
44:            
45:                pCIRead  = &ci1;
0822  0100     MOVLB 0x0
0824  0E00     MOVLW 0x0
0826  6E30     MOVWF 0x30, ACCESS
0828  0100     MOVLB 0x0
082A  0E60     MOVLW 0x60
082C  6E2F     MOVWF pCIRead, ACCESS
46:                pCIWrite = &ci2;
082E  0100     MOVLB 0x0
0830  0E00     MOVLW 0x0
0832  6E43     MOVWF 0x43, ACCESS
0834  0100     MOVLB 0x0
0836  0E70     MOVLW 0x70
0838  6E42     MOVWF pCIWrite, ACCESS
47:            
48:                pCIRead  -> numInts = 4;
083A  C02F     MOVFF pCIRead, FSR2
083C  FFD9     NOP
083E  C030     MOVFF 0x30, FSR2H
0840  FFDA     NOP
0842  0E04     MOVLW 0x4
0844  6EDF     MOVWF INDF2, ACCESS
49:                pCIWrite -> numInts = 4;
0846  C042     MOVFF pCIWrite, FSR2
0848  FFD9     NOP
084A  C043     MOVFF 0x43, FSR2H
084C  FFDA     NOP
084E  0E04     MOVLW 0x4
0850  6EDF     MOVWF INDF2, ACCESS
50:            
51:            }
0852  0012     RETURN 0
52:            
53:            /*
54:            ** Tauscht die Puffer
55:            */
56:            
57:            volatile unsigned char syncLock = 0;
58:            volatile unsigned char updated  = 0;
59:            
60:            
61:            /*
62:            **
63:            */
64:            
65:            inline void swapBuffers()  {
66:            
67:            
68:                if (syncLock == 1 || updated == 0)
08F0  0440     DECF syncLock, W, ACCESS
08F2  B4D8     BTFSC STATUS, 2, ACCESS
08F4  0012     RETURN 0
08F6  6641     TSTFSZ updated, ACCESS
08F8  D001     BRA 0x8FC
08FA  0012     RETURN 0
69:                    return;
70:            
71:                updated = 0; 
08FC  0E00     MOVLW 0x0
08FE  6E41     MOVWF updated, ACCESS
72:            
73:                pCITmp   = pCIRead; 
0900  C030     MOVFF 0x30, 0x32
0902  F032     NOP
0904  C02F     MOVFF pCIRead, pCITmp
0906  F031     NOP
74:                pCIRead  = pCIWrite; 
0908  C043     MOVFF 0x43, 0x30
090A  F030     NOP
090C  C042     MOVFF pCIWrite, pCIRead
090E  F02F     NOP
75:                pCIWrite = pCITmp;
0910  C032     MOVFF 0x32, 0x43
0912  F043     NOP
0914  C031     MOVFF pCITmp, pCIWrite
0916  F042     NOP
76:            
77:            }
0918  0012     RETURN 0
78:            
79:            
80:            
81:            int hilffunktionZumOptimizerAustricksen()  {
82:            
83:                unsigned char i;
84:            
85:                for (i = 1; i < PORTA; i++)  {
86:                    i *= 2;
87:                }
88:            
89:                return (int)i;
90:            }
91:            
92:            
93:            
94:            /*
95:            
96:            void setChannelValue(unsigned char channel, unsigned char value)  {
97:            
98:                if ((channelLevel[channel] == 0) && (value > 0))  {
99:            
100:                  hilffunktionZumOptimizerAustricksen(); 
101:            
102:               }
103:               channelLevel[channel] = value;
104:           
105:           }
106:           */
107:           
108:           /*
109:           unsigned char getChannelValue(unsigned char channel)  {
110:           
111:               if ( channel >= MAXCHANNELS)
112:                   return 0;
113:           
114:               return channelLevel[channel];
115:               
116:           }
117:           
118:           */
119:           
120:           /*
121:           ** Ranking berechnen
122:           */
123:           
124:           void doRank(void )   {
125:           
126:              unsigned char i, j;
127:           
128:              for ( i = 0; i < MAXCHANNELS; i++)
0590  0E00     MOVLW 0x0
0592  0100     MOVLB 0x0
0594  6F82     MOVWF i, BANKED
0596  D00D     BRA 0x5B2
05AE  0100     MOVLB 0x0
05B0  2B82     INCF i, F, BANKED
05B2  0E03     MOVLW 0x3
05B4  0100     MOVLB 0x0
05B6  6582     CPFSGT i, BANKED
05B8  D7EF     BRA 0x598
129:                  channelRank[i] = 0;				// iteration 4 rank aud j wird sonst überschrieben.
0598  0100     MOVLB 0x0
059A  5182     MOVF i, W, BANKED
059C  0D01     MULLW 0x1
059E  0E29     MOVLW 0x29
05A0  24F3     ADDWF PROD, W, ACCESS
05A2  6ED9     MOVWF FSR2, ACCESS
05A4  0E00     MOVLW 0x0
05A6  20F4     ADDWFC PRODH, W, ACCESS
05A8  6EDA     MOVWF FSR2H, ACCESS
05AA  0E00     MOVLW 0x0
05AC  6EDF     MOVWF INDF2, ACCESS
130:           
131:              for ( i = 0; i < MAXCHANNELS-1; i++)  {
05BA  0E00     MOVLW 0x0
05BC  0100     MOVLB 0x0
05BE  6F82     MOVWF i, BANKED
05C0  0E02     MOVLW 0x2
05C2  0100     MOVLB 0x0
05C4  6582     CPFSGT i, BANKED
05C6  D001     BRA 0x5CA
05C8  0012     RETURN 0
062E  0100     MOVLB 0x0
132:           
133:                 for ( j = i + 1; j < MAXCHANNELS;j++)  {
05CA  0100     MOVLB 0x0
05CC  2982     INCF i, W, BANKED
05CE  0100     MOVLB 0x0
05D0  6F81     MOVWF j, BANKED
05D2  D029     BRA 0x626
0622  0100     MOVLB 0x0
0624  2B81     INCF j, F, BANKED
0626  0E03     MOVLW 0x3
0628  0100     MOVLB 0x0
062A  6581     CPFSGT j, BANKED
062C  D7D3     BRA 0x5D4
134:           
135:                     if (channelLevel[i] > channelLevel[j])     
05D4  0100     MOVLB 0x0
05D6  5181     MOVF j, W, BANKED
05D8  0D01     MULLW 0x1
05DA  0E25     MOVLW 0x25
05DC  24F3     ADDWF PROD, W, ACCESS
05DE  6ED9     MOVWF FSR2, ACCESS
05E0  0E00     MOVLW 0x0
05E2  20F4     ADDWFC PRODH, W, ACCESS
05E4  6EDA     MOVWF FSR2H, ACCESS
05E6  50DF     MOVF INDF2, W, ACCESS
05E8  0100     MOVLB 0x0
05EA  6F80     MOVWF __pcstackBANK0, BANKED
05EC  0100     MOVLB 0x0
05EE  5182     MOVF i, W, BANKED
05F0  0D01     MULLW 0x1
05F2  0E25     MOVLW 0x25
05F4  24F3     ADDWF PROD, W, ACCESS
05F6  6ED9     MOVWF FSR2, ACCESS
05F8  0E00     MOVLW 0x0
05FA  20F4     ADDWFC PRODH, W, ACCESS
05FC  6EDA     MOVWF FSR2H, ACCESS
05FE  50DF     MOVF INDF2, W, ACCESS
0600  0100     MOVLB 0x0
0602  5D80     SUBWF __pcstackBANK0, W, BANKED
0604  B0D8     BTFSC STATUS, 0, ACCESS
0606  D003     BRA 0x60E
136:                       channelRank[i]++;
0608  0100     MOVLB 0x0
060A  5182     MOVF i, W, BANKED
060C  D002     BRA 0x612
137:                     else
138:                       channelRank[j]++;  // iteration 3: rank mus auf beiden seiten erhöht werden.
060E  0100     MOVLB 0x0
0610  5181     MOVF j, W, BANKED
0612  0D01     MULLW 0x1
0614  0E29     MOVLW 0x29
0616  24F3     ADDWF PROD, W, ACCESS
0618  6ED9     MOVWF FSR2, ACCESS
061A  0E00     MOVLW 0x0
061C  20F4     ADDWFC PRODH, W, ACCESS
061E  6EDA     MOVWF FSR2H, ACCESS
0620  2ADF     INCF INDF2, F, ACCESS
139:                 }
140:              }
141:           }
142:           
143:           
144:           /*
145:           ** Berechnet  die Timerabstände basierend auf den sortieren kanalhelligkeiten
146:           */
147:           
148:           #define PWMSTEP   16
149:           #define PELOAD100HZ 0xF63C
150:           
151:           
152:           void calculateTimerDiffsAndMask()  {
153:           
154:              unsigned char i;
155:              unsigned char i2;
156:              unsigned int sumTimers;
157:           
158:              unsigned char pivot[MAXCHANNELS];
159:           
160:              for (i = 0; i < MAXCHANNELS; i++)  {
00A6  0E00     MOVLW 0x0
00A8  0100     MOVLB 0x0
00AA  6F91     MOVWF i, BANKED
00AC  D01C     BRA 0xE6
00E2  0100     MOVLB 0x0
00E4  2B91     INCF i, F, BANKED
00E6  0E03     MOVLW 0x3
00E8  0100     MOVLB 0x0
00EA  6591     CPFSGT i, BANKED
00EC  D7E0     BRA 0xAE
161:                 pivot[channelRank[i]] = i;
00AE  0100     MOVLB 0x0
00B0  5191     MOVF i, W, BANKED
00B2  0D01     MULLW 0x1
00B4  0E29     MOVLW 0x29
00B6  24F3     ADDWF PROD, W, ACCESS
00B8  6ED9     MOVWF FSR2, ACCESS
00BA  0E00     MOVLW 0x0
00BC  20F4     ADDWFC PRODH, W, ACCESS
00BE  6EDA     MOVWF FSR2H, ACCESS
00C0  50DF     MOVF INDF2, W, ACCESS
00C2  0100     MOVLB 0x0
00C4  6F80     MOVWF __pcstackBANK0, BANKED
00C6  0100     MOVLB 0x0
00C8  5180     MOVF __pcstackBANK0, W, BANKED
00CA  0D01     MULLW 0x1
00CC  0100     MOVLB 0x0
00CE  0E8C     MOVLW 0x8C
00D0  24F3     ADDWF PROD, W, ACCESS
00D2  6ED9     MOVWF FSR2, ACCESS
00D4  0100     MOVLB 0x0
00D6  0E00     MOVLW 0x0
00D8  20F4     ADDWFC PRODH, W, ACCESS
00DA  6EDA     MOVWF FSR2H, ACCESS
00DC  0100     MOVLB 0x0
00DE  C091     MOVFF i, INDF2
00E0  FFDF     NOP
162:              }
163:              
164:           
165:              syncLock = 1;   // Sperre, ab jetzt wird das schattenregister aufgebaut.
00EE  0E01     MOVLW 0x1
00F0  6E40     MOVWF syncLock, ACCESS
166:           
167:              pCIWrite -> numInts = 4;
00F2  C042     MOVFF pCIWrite, FSR2
00F4  FFD9     NOP
00F6  C043     MOVFF 0x43, FSR2H
00F8  FFDA     NOP
00FA  0E04     MOVLW 0x4
00FC  6EDF     MOVWF INDF2, ACCESS
168:           
169:              /*
170:              ** Nur kanaele einschalten, die auch einen lichtwert haben
171:              */
172:           
173:              pCIWrite -> bitmask[0] = 0x00;
00FE  EE20     LFSR 2, 0xB
0100  F00B     NOP
0102  5042     MOVF pCIWrite, W, ACCESS
0104  26D9     ADDWF FSR2, F, ACCESS
0106  5043     MOVF 0x43, W, ACCESS
0108  22DA     ADDWFC FSR2H, F, ACCESS
010A  0E00     MOVLW 0x0
010C  6EDF     MOVWF INDF2, ACCESS
174:              for ( i = 0; i < MAXCHANNELS; i++)  {
010E  0E00     MOVLW 0x0
0110  0100     MOVLB 0x0
0112  6F91     MOVWF i, BANKED
0114  D02B     BRA 0x16C
0168  0100     MOVLB 0x0
016A  2B91     INCF i, F, BANKED
016C  0E03     MOVLW 0x3
016E  0100     MOVLB 0x0
0170  6591     CPFSGT i, BANKED
0172  D7D1     BRA 0x116
175:                  if (  channelLevel[i] > 0)
0116  0100     MOVLB 0x0
0118  5191     MOVF i, W, BANKED
011A  0D01     MULLW 0x1
011C  0E25     MOVLW 0x25
011E  24F3     ADDWF PROD, W, ACCESS
0120  6ED9     MOVWF FSR2, ACCESS
0122  0E00     MOVLW 0x0
0124  20F4     ADDWFC PRODH, W, ACCESS
0126  6EDA     MOVWF FSR2H, ACCESS
0128  50DF     MOVF INDF2, W, ACCESS
012A  B4D8     BTFSC STATUS, 2, ACCESS
012C  D018     BRA 0x15E
176:                     pCIWrite -> bitmask[0] |= (1 << i);    // einschaltvektor
012E  C091     MOVFF i, __pcstackBANK0
0130  F080     NOP
0132  0E01     MOVLW 0x1
0134  0100     MOVLB 0x0
0136  6F81     MOVWF j, BANKED
0138  0100     MOVLB 0x0
013A  2B80     INCF __pcstackBANK0, F, BANKED
013C  D003     BRA 0x144
013E  0100     MOVLB 0x0
0140  90D8     BCF STATUS, 0, ACCESS
0142  3781     RLCF j, F, BANKED
0144  0100     MOVLB 0x0
0146  2F80     DECFSZ __pcstackBANK0, F, BANKED
0148  D7FA     BRA 0x13E
014A  EE20     LFSR 2, 0xB
014C  F00B     NOP
014E  5042     MOVF pCIWrite, W, ACCESS
0150  26D9     ADDWF FSR2, F, ACCESS
0152  5043     MOVF 0x43, W, ACCESS
0154  22DA     ADDWFC FSR2H, F, ACCESS
0156  0100     MOVLB 0x0
0158  5181     MOVF j, W, BANKED
015A  12DF     IORWF INDF2, F, ACCESS
015C  D005     BRA 0x168
177:                  else  {
178:                     pCIWrite -> numInts--;                 // kanal 0, also weniger interrupts nötig
015E  C042     MOVFF pCIWrite, FSR2
0160  FFD9     NOP
0162  C043     MOVFF 0x43, FSR2H
0164  FFDA     NOP
0166  06DF     DECF INDF2, F, ACCESS
179:                  }
180:              }
181:           
182:              /*
183:              ** Berechnen der Zeitintervalle
184:              */
185:           
186:              i2 = 0;
0174  0E00     MOVLW 0x0
0176  0100     MOVLB 0x0
0178  6F90     MOVWF i2, BANKED
187:              for ( i = 0; i < MAXCHANNELS; i++)  {
017A  0E00     MOVLW 0x0
017C  0100     MOVLB 0x0
017E  6F91     MOVWF i, BANKED
0180  D172     BRA 0x466
0462  0100     MOVLB 0x0
0464  2B91     INCF i, F, BANKED
0466  0E03     MOVLW 0x3
0468  0100     MOVLB 0x0
046A  6591     CPFSGT i, BANKED
046C  D68A     BRA 0x182
188:           
189:                  if ( channelLevel[pivot[i]] == 0)  {
0182  0100     MOVLB 0x0
0184  5191     MOVF i, W, BANKED
0186  0D01     MULLW 0x1
0188  0100     MOVLB 0x0
018A  0E8C     MOVLW 0x8C
018C  24F3     ADDWF PROD, W, ACCESS
018E  6ED9     MOVWF FSR2, ACCESS
0190  0100     MOVLB 0x0
0192  0E00     MOVLW 0x0
0194  20F4     ADDWFC PRODH, W, ACCESS
0196  6EDA     MOVWF FSR2H, ACCESS
0198  50DF     MOVF INDF2, W, ACCESS
019A  0100     MOVLB 0x0
019C  6F80     MOVWF __pcstackBANK0, BANKED
019E  0100     MOVLB 0x0
01A0  5180     MOVF __pcstackBANK0, W, BANKED
01A2  0D01     MULLW 0x1
01A4  0E25     MOVLW 0x25
01A6  24F3     ADDWF PROD, W, ACCESS
01A8  6ED9     MOVWF FSR2, ACCESS
01AA  0E00     MOVLW 0x0
01AC  20F4     ADDWFC PRODH, W, ACCESS
01AE  6EDA     MOVWF FSR2H, ACCESS
01B0  50DF     MOVF INDF2, W, ACCESS
01B2  B4D8     BTFSC STATUS, 2, ACCESS
01B4  D156     BRA 0x462
190:                       continue;
191:                  }
192:           
193:                  if ( i == 0 )  {
01B6  0100     MOVLB 0x0
01B8  6791     TSTFSZ i, BANKED
01BA  D02F     BRA 0x21A
194:                     pCIWrite -> timer[i2] = channelLevel[pivot[i]] * PWMSTEP;
01BC  0100     MOVLB 0x0
01BE  5190     MOVF i2, W, BANKED
01C0  0D02     MULLW 0x2
01C2  0E01     MOVLW 0x1
01C4  26F3     ADDWF PROD, F, ACCESS
01C6  0E00     MOVLW 0x0
01C8  22F4     ADDWFC PRODH, F, ACCESS
01CA  50F3     MOVF PROD, W, ACCESS
01CC  2442     ADDWF pCIWrite, W, ACCESS
01CE  6ED9     MOVWF FSR2, ACCESS
01D0  50F4     MOVF PRODH, W, ACCESS
01D2  2043     ADDWFC 0x43, W, ACCESS
01D4  6EDA     MOVWF FSR2H, ACCESS
01D6  0100     MOVLB 0x0
01D8  5191     MOVF i, W, BANKED
01DA  0D01     MULLW 0x1
01DC  0100     MOVLB 0x0
01DE  0E8C     MOVLW 0x8C
01E0  24F3     ADDWF PROD, W, ACCESS
01E2  6EE1     MOVWF FSR1, ACCESS
01E4  0100     MOVLB 0x0
01E6  0E00     MOVLW 0x0
01E8  20F4     ADDWFC PRODH, W, ACCESS
01EA  6EE2     MOVWF FSR1H, ACCESS
01EC  50E7     MOVF INDF1, W, ACCESS
01EE  0100     MOVLB 0x0
01F0  6F80     MOVWF __pcstackBANK0, BANKED
01F2  0100     MOVLB 0x0
01F4  5180     MOVF __pcstackBANK0, W, BANKED
01F6  0D01     MULLW 0x1
01F8  0E25     MOVLW 0x25
01FA  24F3     ADDWF PROD, W, ACCESS
01FC  6EE1     MOVWF FSR1, ACCESS
01FE  0E00     MOVLW 0x0
0200  20F4     ADDWFC PRODH, W, ACCESS
0202  6EE2     MOVWF FSR1H, ACCESS
0204  50E7     MOVF INDF1, W, ACCESS
0206  0100     MOVLB 0x0
0208  6F81     MOVWF j, BANKED
020A  0100     MOVLB 0x0
020C  5181     MOVF j, W, BANKED
020E  0D10     MULLW 0x10
0210  CFF3     MOVFF PROD, POSTINC2
0212  FFDE     NOP
0214  CFF4     MOVFF PRODH, POSTDEC2
0216  FFDD     NOP
195:                  }
0218  D06F     BRA 0x2F8
196:                  else  {
197:                     pCIWrite -> timer[i2] = (channelLevel[pivot[i]] - channelLevel[pivot[i-1]]) * PWMSTEP;
021A  0EFF     MOVLW 0xFF
021C  0100     MOVLB 0x0
021E  6F80     MOVWF __pcstackBANK0, BANKED
0220  0EFF     MOVLW 0xFF
0222  6F81     MOVWF j, BANKED
0224  0100     MOVLB 0x0
0226  5191     MOVF i, W, BANKED
0228  0100     MOVLB 0x0
022A  6F82     MOVWF i, BANKED
022C  6B83     CLRF 0x83, BANKED
022E  0100     MOVLB 0x0
0230  5180     MOVF __pcstackBANK0, W, BANKED
0232  0100     MOVLB 0x0
0234  2782     ADDWF i, F, BANKED
0236  0100     MOVLB 0x0
0238  5181     MOVF j, W, BANKED
023A  0100     MOVLB 0x0
023C  2383     ADDWFC 0x83, F, BANKED
023E  0100     MOVLB 0x0
0240  0E8C     MOVLW 0x8C
0242  0100     MOVLB 0x0
0244  2582     ADDWF i, W, BANKED
0246  6ED9     MOVWF FSR2, ACCESS
0248  0100     MOVLB 0x0
024A  0E00     MOVLW 0x0
024C  0100     MOVLB 0x0
024E  2183     ADDWFC 0x83, W, BANKED
0250  6EDA     MOVWF FSR2H, ACCESS
0252  50DF     MOVF INDF2, W, ACCESS
0254  0100     MOVLB 0x0
0256  6F84     MOVWF 0x84, BANKED
0258  0100     MOVLB 0x0
025A  5184     MOVF 0x84, W, BANKED
025C  0D01     MULLW 0x1
025E  0E25     MOVLW 0x25
0260  24F3     ADDWF PROD, W, ACCESS
0262  6ED9     MOVWF FSR2, ACCESS
0264  0E00     MOVLW 0x0
0266  20F4     ADDWFC PRODH, W, ACCESS
0268  6EDA     MOVWF FSR2H, ACCESS
026A  50DF     MOVF INDF2, W, ACCESS
026C  0100     MOVLB 0x0
026E  6F85     MOVWF 0x85, BANKED
0270  6B86     CLRF 0x86, BANKED
0272  0100     MOVLB 0x0
0274  1F85     COMF 0x85, F, BANKED
0276  1F86     COMF 0x86, F, BANKED
0278  4B85     INFSNZ 0x85, F, BANKED
027A  2B86     INCF 0x86, F, BANKED
027C  0100     MOVLB 0x0
027E  5191     MOVF i, W, BANKED
0280  0D01     MULLW 0x1
0282  0100     MOVLB 0x0
0284  0E8C     MOVLW 0x8C
0286  24F3     ADDWF PROD, W, ACCESS
0288  6ED9     MOVWF FSR2, ACCESS
028A  0100     MOVLB 0x0
028C  0E00     MOVLW 0x0
028E  20F4     ADDWFC PRODH, W, ACCESS
0290  6EDA     MOVWF FSR2H, ACCESS
0292  50DF     MOVF INDF2, W, ACCESS
0294  0100     MOVLB 0x0
0296  6F87     MOVWF 0x87, BANKED
0298  0100     MOVLB 0x0
029A  5187     MOVF 0x87, W, BANKED
029C  0D01     MULLW 0x1
029E  0E25     MOVLW 0x25
02A0  24F3     ADDWF PROD, W, ACCESS
02A2  6ED9     MOVWF FSR2, ACCESS
02A4  0E00     MOVLW 0x0
02A6  20F4     ADDWFC PRODH, W, ACCESS
02A8  6EDA     MOVWF FSR2H, ACCESS
02AA  50DF     MOVF INDF2, W, ACCESS
02AC  0100     MOVLB 0x0
02AE  6F88     MOVWF 0x88, BANKED
02B0  6B89     CLRF 0x89, BANKED
02B2  0100     MOVLB 0x0
02B4  5185     MOVF 0x85, W, BANKED
02B6  0100     MOVLB 0x0
02B8  2788     ADDWF 0x88, F, BANKED
02BA  0100     MOVLB 0x0
02BC  5186     MOVF 0x86, W, BANKED
02BE  0100     MOVLB 0x0
02C0  2389     ADDWFC 0x89, F, BANKED
02C2  0100     MOVLB 0x0
02C4  3B88     SWAPF 0x88, F, BANKED
02C6  3B89     SWAPF 0x89, F, BANKED
02C8  0EF0     MOVLW 0xF0
02CA  1789     ANDWF 0x89, F, BANKED
02CC  5188     MOVF 0x88, W, BANKED
02CE  0B0F     ANDLW 0xF
02D0  1389     IORWF 0x89, F, BANKED
02D2  0EF0     MOVLW 0xF0
02D4  1788     ANDWF 0x88, F, BANKED
02D6  0100     MOVLB 0x0
02D8  5190     MOVF i2, W, BANKED
02DA  0D02     MULLW 0x2
02DC  0E01     MOVLW 0x1
02DE  26F3     ADDWF PROD, F, ACCESS
02E0  0E00     MOVLW 0x0
02E2  22F4     ADDWFC PRODH, F, ACCESS
02E4  50F3     MOVF PROD, W, ACCESS
02E6  2442     ADDWF pCIWrite, W, ACCESS
02E8  6ED9     MOVWF FSR2, ACCESS
02EA  50F4     MOVF PRODH, W, ACCESS
02EC  2043     ADDWFC 0x43, W, ACCESS
02EE  6EDA     MOVWF FSR2H, ACCESS
02F0  C088     MOVFF 0x88, POSTINC2
02F2  FFDE     NOP
02F4  C089     MOVFF 0x89, POSTDEC2
02F6  FFDD     NOP
198:                  }
199:           
200:                  pCIWrite -> bitmask[i2+1] = (1 << pivot[i]);
02F8  0100     MOVLB 0x0
02FA  5190     MOVF i2, W, BANKED
02FC  0100     MOVLB 0x0
02FE  6F80     MOVWF __pcstackBANK0, BANKED
0300  6B81     CLRF j, BANKED
0302  0E0C     MOVLW 0xC
0304  0100     MOVLB 0x0
0306  2780     ADDWF __pcstackBANK0, F, BANKED
0308  0E00     MOVLW 0x0
030A  2381     ADDWFC j, F, BANKED
030C  0100     MOVLB 0x0
030E  5180     MOVF __pcstackBANK0, W, BANKED
0310  2442     ADDWF pCIWrite, W, ACCESS
0312  6ED9     MOVWF FSR2, ACCESS
0314  0100     MOVLB 0x0
0316  5181     MOVF j, W, BANKED
0318  2043     ADDWFC 0x43, W, ACCESS
031A  6EDA     MOVWF FSR2H, ACCESS
031C  0100     MOVLB 0x0
031E  5191     MOVF i, W, BANKED
0320  0D01     MULLW 0x1
0322  0100     MOVLB 0x0
0324  0E8C     MOVLW 0x8C
0326  24F3     ADDWF PROD, W, ACCESS
0328  6EE1     MOVWF FSR1, ACCESS
032A  0100     MOVLB 0x0
032C  0E00     MOVLW 0x0
032E  20F4     ADDWFC PRODH, W, ACCESS
0330  6EE2     MOVWF FSR1H, ACCESS
0332  50E7     MOVF INDF1, W, ACCESS
0334  0100     MOVLB 0x0
0336  6F82     MOVWF i, BANKED
0338  0E01     MOVLW 0x1
033A  0100     MOVLB 0x0
033C  6F83     MOVWF 0x83, BANKED
033E  0100     MOVLB 0x0
0340  2B82     INCF i, F, BANKED
0342  D003     BRA 0x34A
0344  0100     MOVLB 0x0
0346  90D8     BCF STATUS, 0, ACCESS
0348  3783     RLCF 0x83, F, BANKED
034A  0100     MOVLB 0x0
034C  2F82     DECFSZ i, F, BANKED
034E  D7FA     BRA 0x344
0350  0100     MOVLB 0x0
0352  5183     MOVF 0x83, W, BANKED
0354  6EDF     MOVWF INDF2, ACCESS
201:           
202:                  /*
203:                  ** Behandlen gleicher kanalwerte
204:                  */
205:           
206:                  while ((i < (MAXCHANNELS - 1)) && (channelLevel[pivot[i]] == channelLevel[pivot[i+1]] ) )  {
0356  D03F     BRA 0x3D6
207:                        pCIWrite -> bitmask[i2+1] |= (1 << pivot[i+1]);
0358  0100     MOVLB 0x0
035A  5191     MOVF i, W, BANKED
035C  0100     MOVLB 0x0
035E  6F80     MOVWF __pcstackBANK0, BANKED
0360  6B81     CLRF j, BANKED
0362  0E01     MOVLW 0x1
0364  0100     MOVLB 0x0
0366  2780     ADDWF __pcstackBANK0, F, BANKED
0368  0E00     MOVLW 0x0
036A  2381     ADDWFC j, F, BANKED
036C  0100     MOVLB 0x0
036E  0E8C     MOVLW 0x8C
0370  0100     MOVLB 0x0
0372  2580     ADDWF __pcstackBANK0, W, BANKED
0374  6ED9     MOVWF FSR2, ACCESS
0376  0100     MOVLB 0x0
0378  0E00     MOVLW 0x0
037A  0100     MOVLB 0x0
037C  2181     ADDWFC j, W, BANKED
037E  6EDA     MOVWF FSR2H, ACCESS
0380  50DF     MOVF INDF2, W, ACCESS
0382  0100     MOVLB 0x0
0384  6F82     MOVWF i, BANKED
0386  0E01     MOVLW 0x1
0388  0100     MOVLB 0x0
038A  6F83     MOVWF 0x83, BANKED
038C  0100     MOVLB 0x0
038E  2B82     INCF i, F, BANKED
0390  D003     BRA 0x398
0392  0100     MOVLB 0x0
0394  90D8     BCF STATUS, 0, ACCESS
0396  3783     RLCF 0x83, F, BANKED
0398  0100     MOVLB 0x0
039A  2F82     DECFSZ i, F, BANKED
039C  D7FA     BRA 0x392
039E  0100     MOVLB 0x0
03A0  5190     MOVF i2, W, BANKED
03A2  0100     MOVLB 0x0
03A4  6F84     MOVWF 0x84, BANKED
03A6  6B85     CLRF 0x85, BANKED
03A8  0E0C     MOVLW 0xC
03AA  0100     MOVLB 0x0
03AC  2784     ADDWF 0x84, F, BANKED
03AE  0E00     MOVLW 0x0
03B0  2385     ADDWFC 0x85, F, BANKED
03B2  0100     MOVLB 0x0
03B4  5184     MOVF 0x84, W, BANKED
03B6  2442     ADDWF pCIWrite, W, ACCESS
03B8  6ED9     MOVWF FSR2, ACCESS
03BA  0100     MOVLB 0x0
03BC  5185     MOVF 0x85, W, BANKED
03BE  2043     ADDWFC 0x43, W, ACCESS
03C0  6EDA     MOVWF FSR2H, ACCESS
03C2  0100     MOVLB 0x0
03C4  5183     MOVF 0x83, W, BANKED
03C6  12DF     IORWF INDF2, F, ACCESS
208:                        i++;
03C8  0100     MOVLB 0x0
03CA  2B91     INCF i, F, BANKED
209:                        pCIWrite -> numInts--;
03CC  C042     MOVFF pCIWrite, FSR2
03CE  FFD9     NOP
03D0  C043     MOVFF 0x43, FSR2H
03D2  FFDA     NOP
03D4  06DF     DECF INDF2, F, ACCESS
210:                  }
03D6  0E03     MOVLW 0x3
03D8  0100     MOVLB 0x0
03DA  5D91     SUBWF i, W, BANKED
03DC  B0D8     BTFSC STATUS, 0, ACCESS
03DE  D03F     BRA 0x45E
03E0  0100     MOVLB 0x0
03E2  5191     MOVF i, W, BANKED
03E4  0100     MOVLB 0x0
03E6  6F80     MOVWF __pcstackBANK0, BANKED
03E8  6B81     CLRF j, BANKED
03EA  0E01     MOVLW 0x1
03EC  0100     MOVLB 0x0
03EE  2780     ADDWF __pcstackBANK0, F, BANKED
03F0  0E00     MOVLW 0x0
03F2  2381     ADDWFC j, F, BANKED
03F4  0100     MOVLB 0x0
03F6  0E8C     MOVLW 0x8C
03F8  0100     MOVLB 0x0
03FA  2580     ADDWF __pcstackBANK0, W, BANKED
03FC  6ED9     MOVWF FSR2, ACCESS
03FE  0100     MOVLB 0x0
0400  0E00     MOVLW 0x0
0402  0100     MOVLB 0x0
0404  2181     ADDWFC j, W, BANKED
0406  6EDA     MOVWF FSR2H, ACCESS
0408  50DF     MOVF INDF2, W, ACCESS
040A  0100     MOVLB 0x0
040C  6F82     MOVWF i, BANKED
040E  0100     MOVLB 0x0
0410  5182     MOVF i, W, BANKED
0412  0D01     MULLW 0x1
0414  0E25     MOVLW 0x25
0416  24F3     ADDWF PROD, W, ACCESS
0418  6ED9     MOVWF FSR2, ACCESS
041A  0E00     MOVLW 0x0
041C  20F4     ADDWFC PRODH, W, ACCESS
041E  6EDA     MOVWF FSR2H, ACCESS
0420  50DF     MOVF INDF2, W, ACCESS
0422  0100     MOVLB 0x0
0424  6F83     MOVWF 0x83, BANKED
0426  0100     MOVLB 0x0
0428  5191     MOVF i, W, BANKED
042A  0D01     MULLW 0x1
042C  0100     MOVLB 0x0
042E  0E8C     MOVLW 0x8C
0430  24F3     ADDWF PROD, W, ACCESS
0432  6ED9     MOVWF FSR2, ACCESS
0434  0100     MOVLB 0x0
0436  0E00     MOVLW 0x0
0438  20F4     ADDWFC PRODH, W, ACCESS
043A  6EDA     MOVWF FSR2H, ACCESS
043C  50DF     MOVF INDF2, W, ACCESS
043E  0100     MOVLB 0x0
0440  6F84     MOVWF 0x84, BANKED
0442  0100     MOVLB 0x0
0444  5184     MOVF 0x84, W, BANKED
0446  0D01     MULLW 0x1
0448  0E25     MOVLW 0x25
044A  24F3     ADDWF PROD, W, ACCESS
044C  6ED9     MOVWF FSR2, ACCESS
044E  0E00     MOVLW 0x0
0450  20F4     ADDWFC PRODH, W, ACCESS
0452  6EDA     MOVWF FSR2H, ACCESS
0454  50DF     MOVF INDF2, W, ACCESS
0456  0100     MOVLB 0x0
0458  1983     XORWF 0x83, W, BANKED
045A  B4D8     BTFSC STATUS, 2, ACCESS
045C  D77D     BRA 0x358
211:           
212:                  i2++;
045E  0100     MOVLB 0x0
0460  2B90     INCF i2, F, BANKED
213:              }
214:           
215:              /*
216:              ** "Auffüllen"
217:              */
218:           
219:              sumTimers = 0;
046E  0E00     MOVLW 0x0
0470  0100     MOVLB 0x0
0472  6F8B     MOVWF 0x8B, BANKED
0474  0E00     MOVLW 0x0
0476  0100     MOVLB 0x0
0478  6F8A     MOVWF sumTimers, BANKED
220:              for ( i = 0; i < i2; i++)  {
047A  0E00     MOVLW 0x0
047C  0100     MOVLB 0x0
047E  6F91     MOVWF i, BANKED
0480  D015     BRA 0x4AC
04A8  0100     MOVLB 0x0
04AA  2B91     INCF i, F, BANKED
04AC  0100     MOVLB 0x0
04AE  5190     MOVF i2, W, BANKED
04B0  0100     MOVLB 0x0
04B2  5D91     SUBWF i, W, BANKED
04B4  A0D8     BTFSS STATUS, 0, ACCESS
04B6  D7E5     BRA 0x482
221:                 sumTimers += pCIWrite -> timer[i];
0482  0100     MOVLB 0x0
0484  5191     MOVF i, W, BANKED
0486  0D02     MULLW 0x2
0488  0E01     MOVLW 0x1
048A  26F3     ADDWF PROD, F, ACCESS
048C  0E00     MOVLW 0x0
048E  22F4     ADDWFC PRODH, F, ACCESS
0490  50F3     MOVF PROD, W, ACCESS
0492  2442     ADDWF pCIWrite, W, ACCESS
0494  6ED9     MOVWF FSR2, ACCESS
0496  50F4     MOVF PRODH, W, ACCESS
0498  2043     ADDWFC 0x43, W, ACCESS
049A  6EDA     MOVWF FSR2H, ACCESS
049C  50DE     MOVF POSTINC2, W, ACCESS
049E  0100     MOVLB 0x0
04A0  278A     ADDWF sumTimers, F, BANKED
04A2  50DD     MOVF POSTDEC2, W, ACCESS
04A4  0100     MOVLB 0x0
04A6  238B     ADDWFC 0x8B, F, BANKED
222:              }
223:           
224:              pCIWrite -> timer[i2] = (0x00ff * PWMSTEP) - sumTimers;
04B8  0EF0     MOVLW 0xF0
04BA  0100     MOVLB 0x0
04BC  6F80     MOVWF __pcstackBANK0, BANKED
04BE  0E0F     MOVLW 0xF
04C0  6F81     MOVWF j, BANKED
04C2  0100     MOVLB 0x0
04C4  C08A     MOVFF sumTimers, i
04C6  F082     NOP
04C8  0100     MOVLB 0x0
04CA  C08B     MOVFF 0x8B, 0x83
04CC  F083     NOP
04CE  0100     MOVLB 0x0
04D0  1F82     COMF i, F, BANKED
04D2  1F83     COMF 0x83, F, BANKED
04D4  4B82     INFSNZ i, F, BANKED
04D6  2B83     INCF 0x83, F, BANKED
04D8  0100     MOVLB 0x0
04DA  5180     MOVF __pcstackBANK0, W, BANKED
04DC  0100     MOVLB 0x0
04DE  2782     ADDWF i, F, BANKED
04E0  0100     MOVLB 0x0
04E2  5181     MOVF j, W, BANKED
04E4  0100     MOVLB 0x0
04E6  2383     ADDWFC 0x83, F, BANKED
04E8  0100     MOVLB 0x0
04EA  5190     MOVF i2, W, BANKED
04EC  0D02     MULLW 0x2
04EE  0E01     MOVLW 0x1
04F0  26F3     ADDWF PROD, F, ACCESS
04F2  0E00     MOVLW 0x0
04F4  22F4     ADDWFC PRODH, F, ACCESS
04F6  50F3     MOVF PROD, W, ACCESS
04F8  2442     ADDWF pCIWrite, W, ACCESS
04FA  6ED9     MOVWF FSR2, ACCESS
04FC  50F4     MOVF PRODH, W, ACCESS
04FE  2043     ADDWFC 0x43, W, ACCESS
0500  6EDA     MOVWF FSR2H, ACCESS
0502  C082     MOVFF i, POSTINC2
0504  FFDE     NOP
0506  C083     MOVFF 0x83, POSTDEC2
0508  FFDD     NOP
225:           
226:              for ( i = 0; i < MAXCHANNELS + 1; i++)  {
050A  0E00     MOVLW 0x0
050C  0100     MOVLB 0x0
050E  6F91     MOVWF i, BANKED
0510  D036     BRA 0x57E
057A  0100     MOVLB 0x0
057C  2B91     INCF i, F, BANKED
057E  0E04     MOVLW 0x4
0580  0100     MOVLB 0x0
0582  6591     CPFSGT i, BANKED
0584  D7C6     BRA 0x512
227:                  pCIWrite -> timer[i] = 0xFFFF - pCIWrite -> timer[i];
0512  0EFF     MOVLW 0xFF
0514  0100     MOVLB 0x0
0516  6F80     MOVWF __pcstackBANK0, BANKED
0518  0EFF     MOVLW 0xFF
051A  6F81     MOVWF j, BANKED
051C  0100     MOVLB 0x0
051E  5191     MOVF i, W, BANKED
0520  0D02     MULLW 0x2
0522  0E01     MOVLW 0x1
0524  26F3     ADDWF PROD, F, ACCESS
0526  0E00     MOVLW 0x0
0528  22F4     ADDWFC PRODH, F, ACCESS
052A  50F3     MOVF PROD, W, ACCESS
052C  2442     ADDWF pCIWrite, W, ACCESS
052E  6ED9     MOVWF FSR2, ACCESS
0530  50F4     MOVF PRODH, W, ACCESS
0532  2043     ADDWFC 0x43, W, ACCESS
0534  6EDA     MOVWF FSR2H, ACCESS
0536  CFDE     MOVFF POSTINC2, i
0538  F082     NOP
053A  CFDD     MOVFF POSTDEC2, 0x83
053C  F083     NOP
053E  0100     MOVLB 0x0
0540  1F82     COMF i, F, BANKED
0542  1F83     COMF 0x83, F, BANKED
0544  4B82     INFSNZ i, F, BANKED
0546  2B83     INCF 0x83, F, BANKED
0548  0100     MOVLB 0x0
054A  5180     MOVF __pcstackBANK0, W, BANKED
054C  0100     MOVLB 0x0
054E  2782     ADDWF i, F, BANKED
0550  0100     MOVLB 0x0
0552  5181     MOVF j, W, BANKED
0554  0100     MOVLB 0x0
0556  2383     ADDWFC 0x83, F, BANKED
0558  0100     MOVLB 0x0
055A  5191     MOVF i, W, BANKED
055C  0D02     MULLW 0x2
055E  0E01     MOVLW 0x1
0560  26F3     ADDWF PROD, F, ACCESS
0562  0E00     MOVLW 0x0
0564  22F4     ADDWFC PRODH, F, ACCESS
0566  50F3     MOVF PROD, W, ACCESS
0568  2442     ADDWF pCIWrite, W, ACCESS
056A  6ED9     MOVWF FSR2, ACCESS
056C  50F4     MOVF PRODH, W, ACCESS
056E  2043     ADDWFC 0x43, W, ACCESS
0570  6EDA     MOVWF FSR2H, ACCESS
0572  C082     MOVFF i, POSTINC2
0574  FFDE     NOP
0576  C083     MOVFF 0x83, POSTDEC2
0578  FFDD     NOP
228:              }
229:           
230:              syncLock = 0;
0586  0E00     MOVLW 0x0
0588  6E40     MOVWF syncLock, ACCESS
231:              updated  = 1;
058A  0E01     MOVLW 0x1
058C  6E41     MOVWF updated, ACCESS
232:           }
0018  CFD8     MOVFF STATUS, __pcstackCOMRAM
001A  F001     NOP
001C  CFE8     MOVFF WREG, 0x2
001E  F002     NOP
0020  CFE0     MOVFF BSR, 0x3
0022  F003     NOP
0024  CFFA     MOVFF PCLATH, 0x4
0026  F004     NOP
0028  CFFB     MOVFF PCLATU, 0x5
002A  F005     NOP
002C  CFE9     MOVFF FSR0, 0x6
002E  F006     NOP
0030  CFEA     MOVFF FSR0H, 0x7
0032  F007     NOP
0034  CFE1     MOVFF FSR1, 0x8
0036  F008     NOP
0038  CFE2     MOVFF FSR1H, 0x9
003A  F009     NOP
003C  CFD9     MOVFF FSR2, 0xA
003E  F00A     NOP
0040  CFDA     MOVFF FSR2H, 0xB
0042  F00B     NOP
0044  CFF3     MOVFF PROD, 0xC
0046  F00C     NOP
0048  CFF4     MOVFF PRODH, 0xD
004A  F00D     NOP
004C  CFF6     MOVFF TBLPTR, 0xE
004E  F00E     NOP
0050  CFF7     MOVFF TBLPTRH, 0xF
0052  F00F     NOP
0054  CFF8     MOVFF TBLPTRU, 0x10
0056  F010     NOP
0058  CFF5     MOVFF TABLAT, 0x11
005A  F011     NOP
058E  0012     RETURN 0
233:           
234:           
